{"version":3,"sources":["msf:///msf-2.0.13.min.js?","msf:///webpack/bootstrap ed7d6cf98eadde729019?","msf:///./index.js?","msf:///./lib/msf.js?","msf:///./lib/EventEmitter.js?","msf:///./lib/Service.js?","msf:///./lib/Search.js?","msf:///./lib/util/index.js?","msf:///./lib/Application.js?","msf:///./lib/Channel.js?","msf:///./lib/util/url.js?","msf:///./lib/util/inherits.js?","msf:///./lib/util/props.js?","msf:///./lib/util/types.js?","msf:///./lib/util/querystring.js?","msf:///./lib/Client.js?","msf:///./lib/ClientList.js?"],"names":["msf","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","undefined","EventEmitter","Service","Search","search","callback","once","services","setTimeout","start","local","getLocal","remote","uri","getByURI","this","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","prototype","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","length","arguments","Error","Array","apply","slice","addListener","listener","newListener","push","warned","console","trace","on","g","removeListener","fired","list","position","splice","off","removeAllListeners","key","ret","listenerCount","emitter","description","name","version","device","props","readOnly","util","Application","Channel","application","channelURI","channel","oReq","XMLHttpRequest","timeout","ontimeout","onload","status","result","JSON","parse","responseText","e","open","send","super_","discoveryFrame","STATUS_STOPPED","self","frame","document","createElement","setAttribute","style","display","src","body","appendChild","windowMessageListener","event","source","contentWindow","data","onSearchReady","results","onSearchResult","onSearchError","window","addEventListener","private","inherits","STATUS_STARTED","postMessage","method","warn","stop","url","types","queryString","service","isString","match","startOnConnect","stopOnDisconnect","disconnectWithHost","clients","me","isHost","client","disconnect","getInfo","invoke","install","oServiceUrl","ClientList","Object","defineProperty","get","connection","readyState","clientId","resultHandlers","connectionUrl","host","pathname","Client","packMessage","oMsg","payload","msg","stringify","msgByteLength","Blob","size","hBuff","ArrayBuffer","hView","DataView","setUint16","unpackMessage","buffer","json","view","msgByteLen","getUint16","String","fromCharCode","getUint8","message","params","isNotification","isConnected","Date","now","connect","attributes","u","WebSocket","binaryType","onopen","_onSocketOpen","bind","onerror","_onSocketError","onclose","_onSocketClose","onmessage","_onSocketMessage","close","publish","target","isArray","to","clear","unpacked","forEach","clientInfo","getById","remove","from","isValid","pattern","oUrl","parser","href","protocol","hostname","port","hash","create","ctor","superCtor","constructor","value","enumerable","writable","configurable","TempCtor","createDescriptor","w","v","obj","k","isNull","isBoolean","str","trim","replace","split","reduce","param","parts","val","decodeURIComponent","hasOwnProperty","keys","map","val2","encodeURIComponent","join","ChannelClient","connectTime","freeze","item","indexOf"],"mappings":"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","file":"msf-2.0.13.min.js","sourcesContent":["var msf =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\t\n\tvar msf = __webpack_require__(1);\n\t\n\tif (true) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return msf; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = msf;\n\t} else {\n\t    window.msf = msf;\n\t}\n\t\n\tmodule.exports = msf;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar EventEmitter = __webpack_require__(2);\n\tvar Service = __webpack_require__(3);\n\tvar Search = __webpack_require__(4);\n\t\n\t// We will use a singleton for search so that we don't create multiple frames in the page\n\tvar search = null;\n\t\n\t\n\t/**\n\t * The entry point for the API\n\t *\n\t * @namespace msf\n\t * @type {EventEmitter}\n\t *\n\t */\n\tvar msf = new EventEmitter();\n\t\n\t\n\t/**\n\t * Searches the local network for compatible multiscreen services\n\t *\n\t * @param {Function} [callback] If a callback is passed the search is immediately started.\n\t * @param {Error} callback.err The callback handler\n\t * @param {Array} callback.result An array of {@link Service} instances found on the network\n\t * @returns {Search} A search instance (a singleton is used to reduce page resources)\n\t *\n\t */\n\tmsf.search = function(callback){\n\t\n\t    // Create the single instance if we don't already have one\n\t    if(!search) search = new Search();\n\t\n\t    // If there is a callback defined, listen once for results and start the search\n\t    if(callback) {\n\t        search.once('found',function(services){\n\t            callback(null, services);\n\t        });\n\t\n\t        // start on next tick to support search callbacks and events\n\t        setTimeout(function(){ search.start(); },0);\n\t\n\t    }\n\t\n\t    return search;\n\t\n\t};\n\t\n\t\n\t/**\n\t * Retrieves a reference to the service running on the current device\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Error} callback.error\n\t * @param {Service} callback.service The service instance\n\t *\n\t */\n\tmsf.local = function(callback){\n\t\n\t    Service.getLocal(callback);\n\t\n\t};\n\t\n\t/**\n\t * Retrieves a service instance by it's uri\n\t *\n\t * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\n\t * @param {Function} callback The callback handler\n\t * @param {Error} callback.error\n\t * @param {Service} callback.service The service instance\n\t *\n\t */\n\tmsf.remote = function(uri, callback){\n\t\n\t    Service.getByURI(uri, callback);\n\t\n\t};\n\t\n\t\n\t\n\tmodule.exports = msf;\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\n\t\n\t\"use strict\";\n\t\n\t/**\n\t * Based on nodejs EventEmitter\n\t *\n\t * - addition of 'off' method as an alias to `removeListener`\n\t *\n\t * All objects which emit events are instances of EventEmitter.\n\t * For more information see http://nodejs.org/api/events.html\n\t *\n\t * @namespace EventEmitter\n\t *\n\t */\n\t\n\t\n\t/**\n\t * Adds a listener to the end of the listeners array for the specified event.\n\t * @method addListener\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to listen to\n\t * @param {Function} listener The function to invoke when the event occurs\n\t * @return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * Alias for addListener method\n\t * @method on\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to listen to\n\t * @param {Function} listener The function to invoke when the event occurs\n\t * @return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\n\t * @method once\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to listen to\n\t * @param {Function} listener The function to invoke when the event occurs\n\t * return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener.\n\t * @method removeListener\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to stop listening to\n\t * @param {Function} listener The function that was originally add to handle the event\n\t * @return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * Alias for removeListener\n\t * @method off\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to stop listening to\n\t * @param {Function} listener The function that was originally add to handle the event\n\t * @return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * Removes all listeners, or those of the specified event.\n\t * @method removeAllListeners\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name to stop listening to\n\t * @return EventEmitter\n\t *\n\t */\n\t\n\t/**\n\t * By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.\n\t * @method setMaxListeners\n\t * @memberOf EventEmitter.prototype\n\t * @param {Number} n The maximum number of listeners\n\t *\n\t */\n\t\n\t/**\n\t * Returns an array of listeners for the specified event.\n\t * @method listeners\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name the listeners are currently bound to\n\t * @return Array\n\t *\n\t */\n\t\n\t/**\n\t * Returns true if event had listeners, false otherwise.\n\t * @method emit\n\t * @memberOf EventEmitter.prototype\n\t * @param {String} event The event name the listeners are currently bound to\n\t * @param {any}[args]*\n\t * @return Boolean\n\t *\n\t */\n\t\n\t/**\n\t * Returns true if event had listeners, false otherwise.\n\t * @method listenerCount\n\t * @static\n\t * @memberOf EventEmitter\n\t * @param {EventEmitter} emitter\n\t * @param {String} event The event name the listeners are currently bound to\n\t * @return Number\n\t *\n\t */\n\t\n\t\n\t/**\n\t This event is emitted any time someone adds a new listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\n\t @event EventEmitter#newListener\n\t @property {String} event The event name\n\t @property {Function} listener The event handler function\n\t **/\n\t\n\t/**\n\t This event is emitted any time someone removes a listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\n\t @event EventEmitter#removeListener\n\t @property {String} event The event name\n\t @property {Function} listener The event handler function\n\t **/\n\t\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t this._events = this._events || {};\n\t this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t if (!isNumber(n) || n < 0 || isNaN(n))\n\t  throw TypeError('n must be a positive number');\n\t this._maxListeners = n;\n\t return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t var er, handler, len, args, i, listeners;\n\t\n\t if (!this._events)\n\t  this._events = {};\n\t\n\t // If there is no 'error' event listener then throw.\n\t if (type === 'error') {\n\t  if (!this._events.error ||\n\t      (isObject(this._events.error) && !this._events.error.length)) {\n\t   er = arguments[1];\n\t   if (er instanceof Error) {\n\t    throw er; // Unhandled 'error' event\n\t   }\n\t   throw TypeError('Uncaught, unspecified \"error\" event.');\n\t  }\n\t }\n\t\n\t handler = this._events[type];\n\t\n\t if (isUndefined(handler))\n\t  return false;\n\t\n\t if (isFunction(handler)) {\n\t  switch (arguments.length) {\n\t   // fast cases\n\t   case 1:\n\t    handler.call(this);\n\t    break;\n\t   case 2:\n\t    handler.call(this, arguments[1]);\n\t    break;\n\t   case 3:\n\t    handler.call(this, arguments[1], arguments[2]);\n\t    break;\n\t   // slower\n\t   default:\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t     args[i - 1] = arguments[i];\n\t    handler.apply(this, args);\n\t  }\n\t } else if (isObject(handler)) {\n\t  len = arguments.length;\n\t  args = new Array(len - 1);\n\t  for (i = 1; i < len; i++)\n\t   args[i - 1] = arguments[i];\n\t\n\t  listeners = handler.slice();\n\t  len = listeners.length;\n\t  for (i = 0; i < len; i++)\n\t   listeners[i].apply(this, args);\n\t }\n\t\n\t return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t var m;\n\t\n\t if (!isFunction(listener))\n\t  throw TypeError('listener must be a function');\n\t\n\t if (!this._events)\n\t  this._events = {};\n\t\n\t // To avoid recursion in the case that type === \"newListener\"! Before\n\t // adding it to the listeners, first emit \"newListener\".\n\t if (this._events.newListener)\n\t  this.emit('newListener', type,\n\t      isFunction(listener.listener) ?\n\t          listener.listener : listener);\n\t\n\t if (!this._events[type])\n\t // Optimize the case of one listener. Don't need the extra array object.\n\t  this._events[type] = listener;\n\t else if (isObject(this._events[type]))\n\t // If we've already got an array, just append.\n\t  this._events[type].push(listener);\n\t else\n\t // Adding the second element, need to change to array.\n\t  this._events[type] = [this._events[type], listener];\n\t\n\t // Check for listener leak\n\t if (isObject(this._events[type]) && !this._events[type].warned) {\n\t  var m;\n\t  if (!isUndefined(this._maxListeners)) {\n\t   m = this._maxListeners;\n\t  } else {\n\t   m = EventEmitter.defaultMaxListeners;\n\t  }\n\t\n\t  if (m && m > 0 && this._events[type].length > m) {\n\t   this._events[type].warned = true;\n\t   console.error('(node) warning: possible EventEmitter memory ' +\n\t       'leak detected. %d listeners added. ' +\n\t       'Use emitter.setMaxListeners() to increase limit.',\n\t       this._events[type].length);\n\t   if (typeof console.trace === 'function') {\n\t    // not supported in IE 10\n\t    console.trace();\n\t   }\n\t  }\n\t }\n\t\n\t return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t if (!isFunction(listener))\n\t  throw TypeError('listener must be a function');\n\t\n\t var fired = false;\n\t\n\t function g() {\n\t  this.removeListener(type, g);\n\t\n\t  if (!fired) {\n\t   fired = true;\n\t   listener.apply(this, arguments);\n\t  }\n\t }\n\t\n\t g.listener = listener;\n\t this.on(type, g);\n\t\n\t return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t var list, position, length, i;\n\t\n\t if (!isFunction(listener))\n\t  throw TypeError('listener must be a function');\n\t\n\t if (!this._events || !this._events[type])\n\t  return this;\n\t\n\t list = this._events[type];\n\t length = list.length;\n\t position = -1;\n\t\n\t if (list === listener ||\n\t     (isFunction(list.listener) && list.listener === listener)) {\n\t  delete this._events[type];\n\t  if (this._events.removeListener)\n\t   this.emit('removeListener', type, listener);\n\t\n\t } else if (isObject(list)) {\n\t  for (i = length; i-- > 0;) {\n\t   if (list[i] === listener ||\n\t       (list[i].listener && list[i].listener === listener)) {\n\t    position = i;\n\t    break;\n\t   }\n\t  }\n\t\n\t  if (position < 0)\n\t   return this;\n\t\n\t  if (list.length === 1) {\n\t   list.length = 0;\n\t   delete this._events[type];\n\t  } else {\n\t   list.splice(position, 1);\n\t  }\n\t\n\t  if (this._events.removeListener)\n\t   this.emit('removeListener', type, listener);\n\t }\n\t\n\t return this;\n\t};\n\t\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t var key, listeners;\n\t\n\t if (!this._events)\n\t  return this;\n\t\n\t // not listening for removeListener, no need to emit\n\t if (!this._events.removeListener) {\n\t  if (arguments.length === 0)\n\t   this._events = {};\n\t  else if (this._events[type])\n\t   delete this._events[type];\n\t  return this;\n\t }\n\t\n\t // emit removeListener for all listeners on all events\n\t if (arguments.length === 0) {\n\t  for (key in this._events) {\n\t   if (key === 'removeListener') continue;\n\t   this.removeAllListeners(key);\n\t  }\n\t  this.removeAllListeners('removeListener');\n\t  this._events = {};\n\t  return this;\n\t }\n\t\n\t listeners = this._events[type];\n\t\n\t if (isFunction(listeners)) {\n\t  this.removeListener(type, listeners);\n\t } else {\n\t  // LIFO order\n\t  while (listeners.length)\n\t   this.removeListener(type, listeners[listeners.length - 1]);\n\t }\n\t delete this._events[type];\n\t\n\t return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t var ret;\n\t if (!this._events || !this._events[type])\n\t  ret = [];\n\t else if (isFunction(this._events[type]))\n\t  ret = [this._events[type]];\n\t else\n\t  ret = this._events[type].slice();\n\t return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t var ret;\n\t if (!emitter._events || !emitter._events[type])\n\t  ret = 0;\n\t else if (isFunction(emitter._events[type]))\n\t  ret = 1;\n\t else\n\t  ret = emitter._events[type].length;\n\t return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t return arg === void 0;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar props = util.props;\n\tvar Application = __webpack_require__(6);\n\tvar Channel = __webpack_require__(7);\n\t\n\t\n\t/**\n\t * A Service instance represents the multiscreen service root on the remote device\n\t * Use the class to control top level services of the device\n\t *\n\t * @namespace Service\n\t *\n\t */\n\t\n\tfunction Service(description){\n\t\n\t    /**\n\t     * The id of the service\n\t     *\n\t     * @member {String} Service#id\n\t     * @readonly\n\t     */\n\t    this.id = description.id;\n\t\n\t    /**\n\t     * The name of the service (Living Room TV)\n\t     *\n\t     * @member {String} Service#name\n\t     * @readonly\n\t     */\n\t    this.name = description.name;\n\t\n\t    /**\n\t     * The version of the service (x.x.x)\n\t     *\n\t     * @member {String} Service#version\n\t     * @readonly\n\t     */\n\t    this.version = description.version;\n\t\n\t    /**\n\t     * The type of the service (Samsung SmartTV)\n\t     *\n\t     * @member {String} Service#type\n\t     * @readonly\n\t     */\n\t    this.type = description.type;\n\t\n\t    /**\n\t     * The uri of the service (http://<ip>:<port>/api/v2/)\n\t     *\n\t     * @member {String} Service#uri\n\t     * @readonly\n\t     */\n\t    this.uri = description.uri;\n\t\n\t    /**\n\t     * A hash of additional information about the device the service is running on\n\t     *\n\t     * @member {String} Service#device\n\t     * @readonly\n\t     */\n\t    this.device = description.device;\n\t\n\t    props.readOnly(this,['id','name','version','type','uri','device']);\n\t\n\t}\n\t\n\t/**\n\t * Factory method for creating application instances belonging to that service\n\t *\n\t * @param {String} id An installed application id or url of the web application\n\t * @param {String} channelURI The uri the underlying channel will connect to.\n\t * @returns {Application}\n\t *\n\t */\n\tService.prototype.application = function(id, channelURI){\n\t\n\t    return new Application(this, id, channelURI);\n\t\n\t};\n\t\n\t/**\n\t * creates a channel of the service ('mychannel')\n\t *\n\t * @param {String} uri The uri of the Channel\n\t * @returns {Channel}\n\t */\n\tService.prototype.channel = function(uri){\n\t\n\t    return new Channel(this, uri);\n\t\n\t};\n\t\n\t\n\t/***\n\t * Retrieves a reference to the service running on the current device\n\t *\n\t * @protected\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Error} callback.err The callback handler\n\t * @param {Service} callback.service The service instance\n\t *\n\t */\n\tService.getLocal = function(callback){\n\t\n\t    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\n\t\n\t};\n\t\n\t/***\n\t * Retrieves a service instance by it's uri\n\t *\n\t * @protected\n\t *\n\t * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\n\t * @param {Function} callback The callback handler\n\t * @param {Error} callback.err The callback handler\n\t * @param {Service} callback.service The service instance\n\t *\n\t */\n\tService.getByURI = function(uri, callback){\n\t\n\t    var oReq = new XMLHttpRequest();\n\t    oReq.timeout = 5000;\n\t    oReq.ontimeout = function(){callback();};\n\t    oReq.onload = function() {\n\t\n\t        if(this.status === 200){\n\t            try{\n\t                var result = JSON.parse(this.responseText);\n\t                callback(null, new Service(result));\n\t            }catch(e){  callback(e); }\n\t        }else{\n\t            callback();\n\t        }\n\t    };\n\t    oReq.open(\"get\", uri, true);\n\t    oReq.send();\n\t\n\t};\n\t\n\t\n\tmodule.exports = Service;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar props = util.props;\n\tvar EventEmitter = __webpack_require__(2);\n\t\n\t\n\t/**\n\t * Provides facilities to stop and start multiscreen service searches.\n\t *\n\t * @namespace Search\n\t * @extends EventEmitter\n\t *\n\t */\n\t\n\tfunction Search(){\n\t\n\t\n\t    Search.super_.call(this);\n\t\n\t    this.discoveryFrame = null;\n\t    this.status = Search.STATUS_STOPPED;\n\t\n\t    var self = this;\n\t\n\t    /* Create the discovery iframe and load the search page */\n\t\n\t    var frame = document.createElement('iframe');\n\t    frame.setAttribute('width', '1');\n\t    frame.setAttribute('height', '1');\n\t    frame.style.display = \"none\";\n\t    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\n\t    document.body.appendChild(frame);\n\t\n\t    /* Add a 'message' listener to the window that checks incoming messages */\n\t\n\t    this.windowMessageListener = function(event){\n\t\n\t        if(event.source === frame.contentWindow){\n\t\n\t            // ready message\n\t            if(event.data && event.data.event === 'discovery.ready'){\n\t                self.discoveryFrame = event.source;\n\t                self.onSearchReady();\n\t            }\n\t\n\t            // result message\n\t            else if(event.data && event.data.event === 'discovery.result'){\n\t                var results = [];\n\t                var Service = __webpack_require__(3);\n\t                for(var i=0; i<event.data.result.length; i++){\n\t                    results.push(new Service(event.data.result[i]));\n\t                }\n\t                self.onSearchResult(results);\n\t            }\n\t\n\t            // error message\n\t            else if(event.data && event.data.event === 'discovery.error'){\n\t                self.onSearchError(event.data.error);\n\t                this.status = Search.STATUS_STOPPED;\n\t            }\n\t        }\n\t    };\n\t    window.addEventListener('message', this.windowMessageListener);\n\t\n\t    props.private(this,['discoveryFrame','windowMessageListener']);\n\t\n\t}\n\t\n\tutil.inherits(Search, EventEmitter);\n\t\n\t\n\t/***\n\t * @constant {string}\n\t * @private\n\t */\n\tSearch.STATUS_STOPPED = 'stopped';\n\t\n\t/***\n\t * @constant {string}\n\t * @private\n\t */\n\tSearch.STATUS_STARTED = 'started';\n\t\n\t/***\n\t * @private\n\t */\n\tSearch.prototype.onSearchReady = function(){\n\t    this.emit('ready');\n\t};\n\t\n\t\n\t\n\t/**\n\t * Fired when a search has discovered compatible services\n\t *\n\t * @event Search#found\n\t * @type {Array}\n\t */\n\t\n\t/***\n\t * @private\n\t */\n\tSearch.prototype.onSearchResult = function(results){\n\t    if(this.status !== Search.STATUS_STOPPED){\n\t        this.emit('found',results);\n\t    }\n\t    this.status = Search.STATUS_STOPPED;\n\t};\n\t\n\t\n\t/**\n\t * Fired when a search error has occurred\n\t *\n\t * @event Search#error\n\t * @type {Error}\n\t */\n\t\n\t/***\n\t * @private\n\t */\n\tSearch.prototype.onSearchError = function(error){\n\t    this.emit('error',error);\n\t    this.status = Search.STATUS_STOPPED;\n\t};\n\t\n\t\n\t/**\n\t * Starts the search, looking for devices it can reach on the local network\n\t * If a search is already in progress it will NOT begin a new search\n\t */\n\tSearch.prototype.start = function(){\n\t    if(this.status === Search.STATUS_STOPPED){\n\t        if(this.discoveryFrame){\n\t            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\n\t        }else{\n\t            var self = this;\n\t            this.once('ready',function(){\n\t                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\n\t            });\n\t        }\n\t\n\t        this.status = Search.STATUS_STARTED;\n\t        /**\n\t         * Fired when a search has been started\n\t         *\n\t         * @event Search#start\n\t         * @type {Search}\n\t         */\n\t        this.emit('start', this);\n\t    }else{\n\t        console.warn('a previous search is already in progress');\n\t    }\n\t};\n\t\n\t/**\n\t * Stops the current search in progress (no 'found' events or search callbacks will fire)\n\t */\n\tSearch.prototype.stop = function(){\n\t    this.status = Search.STATUS_STOPPED;\n\t    /**\n\t     * Fired when a search has been stopped\n\t     *\n\t     * @event Search#stop\n\t     * @type {Search}\n\t     */\n\t    this.emit('stop', this);\n\t};\n\t\n\t\n\tmodule.exports = Search;\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t\n\t    url         : __webpack_require__(8),\n\t    inherits    : __webpack_require__(9),\n\t    props       : __webpack_require__(10),\n\t    types       : __webpack_require__(11),\n\t    queryString : __webpack_require__(12)\n\t\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar types = util.types;\n\tvar props = util.props;\n\tvar Channel = __webpack_require__(7);\n\t\n\t\n\t/**\n\t * An Application represents an application on the local or remote device.\n\t * Use the class to control various aspects of the application such launching the app or getting information\n\t *\n\t * @namespace Application\n\t * @extends Channel\n\t *\n\t */\n\t\n\tfunction Application(service, id, channelURI){\n\t\n\t    /* Type checking */\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\n\t    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\n\t\n\t    /***\n\t     * The type of application (web application or installable app)\n\t     * @member {String} Application#type\n\t     * @private\n\t     */\n\t    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? 'webapplication' : 'application';\n\t\n\t    /* Super Constructor */\n\t    Application.super_.call(this, service, channelURI);\n\t\n\t\n\t    /**\n\t     * The id of the application (this can be a url or installed application id)\n\t     * @member {String} Application#id\n\t     * @readonly\n\t     */\n\t    this.id = id;\n\t\n\t    /**\n\t     * Auto starts the application when connect is called\n\t     * This configuration property has no effect when used in a SmartTV application\n\t     *\n\t     * @member {Boolean} Application#startOnConnect\n\t     * @default [true]\n\t     * @example\n\t     * ```\n\t     * var app = service.application('myid');\n\t     * app.startOnConnect = false;\n\t     * app.connect(); // The application will not start on the TV\n\t     * ```\n\t     */\n\t    this.startOnConnect      = true;\n\t\n\t    /**\n\t     * Stops the application when disconnect is called and your client is the last client connected\n\t     * This configuration property has no effect when used in a SmartTV application\n\t     *\n\t     * @member {Boolean} Application#stopOnDisconnect\n\t     * @default [true]\n\t     * @example\n\t     * ```\n\t     * var app = service.application('myid');\n\t     * app.stopOnDisconnect = false;\n\t     * app.disconnect(); // The application will not close on the TV\n\t     * ```\n\t     */\n\t    this.stopOnDisconnect    = true;\n\t\n\t    /**\n\t     * Disconnects your client when the host connection ends (when the host application is exited)\n\t     * This configuration property has no effect when used in a SmartTV application\n\t     *\n\t     * @member {Boolean} Application#disconnectWithHost\n\t     * @default [true]\n\t     * @example\n\t     * ```\n\t     * app.on('clientDisconnect', function(client){\n\t     *    // client.isHost == true; but you will not be disconnected.\n\t     * });\n\t     * ```\n\t     */\n\t    this.disconnectWithHost  = true;\n\t\n\t\n\t    var self = this;\n\t\n\t    /* Listen for connect events and call start if startOnConnect */\n\t    this.on('connect', function(client){\n\t        if(self.startOnConnect && !self.clients.me.isHost) this.start();\n\t    });\n\t\n\t    /* Listen for clientDisconnect events and disconnect if host disconnects  */\n\t    this.on('clientDisconnect', function(client){\n\t        if(self.disconnectWithHost && client.isHost) this.disconnect();\n\t    });\n\t\n\t    /* Overwrite super disconnect and stop the app if stopOnDisconnect */\n\t    this.disconnect = function(callback){\n\t        if(self.stopOnDisconnect && self.clients.length < 3) {\n\t            self.stop(function(){\n\t                Channel.prototype.disconnect.call(self, callback);\n\t            });\n\t        }else{\n\t            Channel.prototype.disconnect.call(self, callback);\n\t        }\n\t    };\n\t\n\t    props.readOnly(this,'id');\n\t    props.private(this,'type');\n\t\n\t}\n\t\n\tutil.inherits(Application, Channel);\n\t\n\t\n\t/**\n\t * Retrieves information about the Application on the remote device\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Function} callback.err The callback handler\n\t * @param {Object} callback.result The callback handler\n\t *\n\t */\n\tApplication.prototype.getInfo = function(callback){\n\t\n\t    if(this.type === 'webapplication'){\n\t        this.invoke('ms.webapplication.get', { url: this.id }, callback);\n\t    }else{\n\t        this.invoke('ms.application.get', { id : this.id }, callback);\n\t    }\n\t\n\t};\n\t\n\t\n\t/**\n\t * Launches the application on the remote device\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Function} callback.err The callback handler\n\t *\n\t */\n\tApplication.prototype.start = function(callback){\n\t\n\t    if(this.type === 'webapplication'){\n\t        this.invoke('ms.webapplication.start', { url : this.id }, callback);\n\t    }else{\n\t        this.invoke('ms.application.start', { id : this.id }, callback);\n\t    }\n\t\n\t};\n\t\n\t\n\t/**\n\t * Stop the application on the remote device\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Function} callback.err The callback handler\n\t *\n\t */\n\tApplication.prototype.stop = function(callback){\n\t\n\t    if(this.type === 'webapplication'){\n\t        this.invoke('ms.webapplication.stop', { url : this.id }, callback);\n\t    }else{\n\t        this.invoke('ms.application.stop', { id : this.id }, callback);\n\t    }\n\t\n\t};\n\t\n\t\n\t/**\n\t * Installs the application on the remote device\n\t *\n\t * @param {Function} callback The callback handler\n\t * @param {Function} callback.err The callback handler\n\t *\n\t */\n\tApplication.prototype.install = function(callback){\n\t\n\t    if(this.type === 'webapplication') throw new Error('install cannot be called on web applications');\n\t    this.invoke('ms.application.install', { id : this.id }, callback);\n\t\n\t};\n\t\n\t\n\t\n\t\n\tmodule.exports = Application;\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar types = util.types;\n\tvar props = util.props;\n\tvar EventEmitter = __webpack_require__(2);\n\tvar Client = __webpack_require__(13);\n\tvar ClientList = __webpack_require__(14);\n\t\n\t\n\t/**\n\t * A Channel is a discreet connection where multiple clients can communicate\n\t * @namespace Channel\n\t * @extends EventEmitter\n\t\n\t */\n\tfunction Channel(service, uri){\n\t\n\t    /* Type checking */\n\t    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\n\t    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\n\t\n\t    /* Super Construction */\n\t    Channel.super_.call(this);\n\t\n\t    var self = this;\n\t    var oServiceUrl = util.url.parse(service.uri);\n\t\n\t    /**\n\t     * The uri of the channel ('chat')\n\t     *\n\t     * @member {String} Channel#uri\n\t     * @readonly\n\t     *\n\t     */\n\t    this.uri = uri;\n\t\n\t    /**\n\t     * The collection of clients currently connected to the channel\n\t     *\n\t     * @member {ClientList} Channel#clients\n\t     * @readonly\n\t     *\n\t     */\n\t    this.clients = new ClientList(this);\n\t\n\t    /**\n\t     * The connection status of the channel\n\t     *\n\t     * @member {Boolean} Channel#isConnected\n\t     * @readonly\n\t     *\n\t     */\n\t    Object.defineProperty(this, 'isConnected', {\n\t        get : function(){\n\t            return self.connection && self.connection.readyState === 1;\n\t        }\n\t    });\n\t\n\t    /***\n\t     * The id assigned to your client upon connection\n\t     *\n\t     * @member {String} Channel#clientId\n\t     * @private\n\t     *\n\t     */\n\t    this.clientId = null;\n\t\n\t    /***\n\t     * The underlying web socket connection\n\t     *\n\t     * @member {WebSocket} Channel#connection\n\t     * @private\n\t     *\n\t     */\n\t    this.connection = null;\n\t\n\t    /***\n\t     * A map of message handler still waiting for responses\n\t     *\n\t     * @member {Object} Channel#resultHandlers\n\t     * @private\n\t     *\n\t     */\n\t    this.resultHandlers = {};\n\t\n\t    /***\n\t     * The url for the websocket to connect to\n\t     *\n\t     * @member {Object} Channel#connectionUrl\n\t     * @private\n\t     *\n\t     */\n\t    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\n\t\n\t\n\t    props.private(this, ['clientId','connection','resultHandlers','connectionUrl']);\n\t    props.readOnly(this, ['uri','clients']);\n\t}\n\t\n\t\n\tutil.inherits(Channel, EventEmitter);\n\t\n\t\n\t/*\n\t Packs messages with payloads into binary message\n\t */\n\tChannel.packMessage = function(oMsg, payload){\n\t\n\t    // convert js object to string\n\t    var msg = JSON.stringify(oMsg);\n\t\n\t    // get byte length of the string\n\t    var msgByteLength = new Blob([msg]).size;\n\t\n\t    // create 2 byte header which contains the length of the string (json) message\n\t    var hBuff = new ArrayBuffer(2);\n\t    var hView = new DataView(hBuff);\n\t    hView.setUint16(0,msgByteLength);\n\t\n\t    // binary packed message and payload\n\t    return new Blob([hBuff, msg, payload]);\n\t\n\t};\n\t\n\t/*\n\t Unpacks binary messages\n\t */\n\tChannel.unpackMessage = function(buffer){\n\t\n\t    var json = '';\n\t    var view = new DataView(buffer);\n\t    var msgByteLen = view.getUint16(0);\n\t\n\t    for (var i = 0; i < msgByteLen; i++) {\n\t        json += String.fromCharCode(view.getUint8(i+2));\n\t    }\n\t\n\t    var payload = buffer.slice(2+msgByteLen);\n\t    var message = JSON.parse(json);\n\t\n\t    return {payload : payload, message : message};\n\t\n\t};\n\t\n\t\n\t/***\n\t * Invokes and RPC method on the server\n\t *\n\t * @protected\n\t *\n\t * @param {String} method The name of the method to invoke\n\t * @param {Object} params Named params to pass to the method\n\t * @param {Function} [callback] The success callback handler\n\t * @param {Error} callback.error Any error that may have occurred\n\t * @param {Boolean} callback.success\n\t * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\n\t * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\n\t *\n\t */\n\tChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\n\t\n\t    if(!this.isConnected) throw new Error(\"the channel is disconnected\");\n\t    if(!types.isString(method))throw new TypeError('method must be a valid string');\n\t\n\t    params = params || {};\n\t\n\t    var msg = {\n\t        method  : method,\n\t        params  : params\n\t    };\n\t\n\t    if(callback && !isNotification){\n\t        msg.id = Date.now();\n\t        this.resultHandlers[msg.id] = callback;\n\t    }\n\t\n\t    if(payload){\n\t        msg = Channel.packMessage(msg,payload);\n\t    }else{\n\t        msg = JSON.stringify(msg);\n\t    }\n\t\n\t    this.connection.send(msg);\n\t};\n\t\n\t/**\n\t * Connects to the channel\n\t *\n\t * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\n\t * @param {Function} callback The success callback handler\n\t * @param {Error} callback.error Any error that may have occurred\n\t * @param {Channel} callback.channel The channel instance that connected\n\t *\n\t */\n\tChannel.prototype.connect = function(attributes, callback){\n\t\n\t    if(types.isFunction(attributes) && !callback){\n\t        callback = attributes;\n\t        attributes = {};\n\t    }else{\n\t        attributes = attributes || {};\n\t    }\n\t\n\t    // Validate arguments and connection state\n\t    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\n\t    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\n\t    if(this.isConnected) return console.warn('Channel is already connected.');\n\t\n\t    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\n\t    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\n\t\n\t    // Connect the websocket and add our listeners\n\t    if(!this.connection){\n\t        this.connection = new WebSocket(u);\n\t        this.connection.binaryType = \"arraybuffer\";\n\t        this.connection.onopen = this._onSocketOpen.bind(this);\n\t        this.connection.onerror = this._onSocketError.bind(this);\n\t        this.connection.onclose = this._onSocketClose.bind(this);\n\t        this.connection.onmessage = this._onSocketMessage.bind(this);\n\t    }\n\t\n\t    // Listen once for connect if there was a callback\n\t    var self = this;\n\t    if(callback){\n\t        this.once('connect', function(client){\n\t            callback(null, self);\n\t        });\n\t    }\n\t\n\t\n\t};\n\t\n\t\n\t/**\n\t * Disconnects from the channel\n\t *\n\t * @param {Function} callback The success callback handler\n\t * @param {Error} callback.error Any error that may have occurred\n\t * @param {Channel} callback.channel The channel instance\n\t *\n\t */\n\tChannel.prototype.disconnect = function(callback){\n\t\n\t    if(!this.isConnected) throw new Error(\"the channel is already disconnected\");\n\t    this.connection.close();\n\t    var self = this;\n\t    setTimeout(function(){\n\t        if(callback) callback(null, self);\n\t    },0);\n\t\n\t};\n\t\n\t\n\t/**\n\t * Publish an event message to the specified target or targets.\n\t * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\n\t *\n\t * @param {String} event The name of the event to emit\n\t * @param {any} [message] Any data associated with the event\n\t * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\n\t * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\n\t *\n\t */\n\tChannel.prototype.publish = function(event, message, target, payload){\n\t\n\t    target = target || 'broadcast';\n\t    message = message || null;\n\t\n\t    if(!this.isConnected) throw new Error(\" the channel is not connected\");\n\t    if(!types.isString(event))throw new TypeError('event must be a valid string');\n\t\n\t    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\n\t\n\t    this.invoke('ms.channel.emit',{\n\t        event   : event,\n\t        data    : message,\n\t        to      : target\n\t    }, null, true, payload);\n\t\n\t};\n\t\n\t\n\t\n\t\n\t\n\t// TODO : Make these non enumerable\n\t\n\t\n\tChannel.prototype._onSocketOpen = function() {\n\t    // nothing to do here for now\n\t};\n\t\n\tChannel.prototype._onSocketClose = function() {\n\t    /**\n\t     * Fired when a channel disconnects\n\t     *\n\t     * @event Channel#disconnect\n\t     * @type {Client}\n\t     */\n\t    var client = this.clients.me;\n\t    this.clients.clear();\n\t    this.emit('disconnect',client);\n\t};\n\t\n\tChannel.prototype._onSocketError = function() {\n\t    this.emit('error', new Error(\"WebSocket error\"));\n\t};\n\t\n\t\n\tChannel.prototype._onSocketMessage = function(msg){\n\t\n\t    var client;\n\t    var payload;\n\t\n\t    try{\n\t        if(typeof msg.data === \"string\"){\n\t            msg = JSON.parse(msg.data);\n\t        }else{\n\t            var unpacked = Channel.unpackMessage(msg.data);\n\t            msg = unpacked.message;\n\t            payload = unpacked.payload;\n\t        }\n\t    } catch (e) {\n\t        console.warn('unable to parse message', msg);\n\t        return;\n\t    }\n\t\n\t    if(msg.id && (msg.result || msg.error)){\n\t\n\t        if(!this.resultHandlers[msg.id]){\n\t            console.warn('unable to find result handler for result message ', msg);\n\t            return;\n\t        }\n\t\n\t        this.resultHandlers[msg.id](msg.error,msg.result);\n\t\n\t    }else if (msg.event){\n\t\n\t        switch(msg.event){\n\t\n\t            case 'ms.channel.connect' :\n\t\n\t                // Store my id\n\t                this.clientId = msg.data.id;\n\t\n\t                // Store the current connected client\n\t                msg.data.clients.forEach(function(clientInfo){\n\t\n\t                    // Create a client and add to our list\n\t                    client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\n\t                    this.clients.push(client);\n\t\n\t                },this);\n\t\n\t                /**\n\t                 * Fired when a channel makes a connection\n\t                 *\n\t                 * @event Channel#connect\n\t                 * @type {Client}\n\t                 */\n\t                this.emit('connect',this.clients.me);\n\t\n\t                break;\n\t\n\t            case 'ms.channel.clientConnect' :\n\t\n\t                client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\n\t                this.clients.push(client);\n\t\n\t                /**\n\t                 * Fired when a peer client channel makes a connection\n\t                 *\n\t                 * @event Channel#clientConnect\n\t                 * @type {Client}\n\t                 */\n\t\n\t                this.emit('clientConnect',client);\n\t                break;\n\t\n\t            case 'ms.channel.clientDisconnect' :\n\t\n\t                client = this.clients.getById(msg.data.id);\n\t                if(client) this.clients.remove(client);\n\t                else {\n\t                    console.warn('client '+msg.data.id+' could not be found, so it was not removed from the client list');\n\t                    client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\n\t                }\n\t\n\t                /**\n\t                 * Fired when a peer client disconnects\n\t                 *\n\t                 * @event Channel#clientDisconnect\n\t                 * @type {Client}\n\t                 */\n\t                this.emit('clientDisconnect',client);\n\t                break;\n\t\n\t            case 'ms.channel.ready' :\n\t\n\t\n\t                /**\n\t                 * Convenience event indicating the host has connected and is ready to accept messages\n\t                 *\n\t                 * @event Channel#ready\n\t                 */\n\t                this.emit('ready');\n\t                break;\n\t\n\t\n\t            default :\n\t\n\t                client = this.clients.getById(msg.from);\n\t                var event = msg.event;\n\t                var data  = msg.data;\n\t\n\t                this.emit(event, data, client, payload);\n\t                break;\n\t\n\t        }\n\t\n\t    }else{\n\t        console.warn('unrecognized message type', msg);\n\t    }\n\t\n\t};\n\t\n\tmodule.exports = Channel;\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar queryString = __webpack_require__(12);\n\t\n\tvar url = {\n\t\n\t    isValid : function(u){\n\t\n\t        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\n\t        return u.match(pattern) ? true : false;\n\t    },\n\t\n\t    parse : function(u){\n\t\n\t        var oUrl = {};\n\t        var parser = document.createElement('a');\n\t        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\n\t\n\t        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\n\t        oUrl.protocol = parser.protocol; // => \"http:\"\n\t        oUrl.hostname = parser.hostname; // => \"example.com\"\n\t        oUrl.port = parser.port;     // => \"3000\"\n\t        oUrl.pathname = parser.pathname; // => \"/pathname/\"\n\t        oUrl.search = parser.search;   // => \"?search=test\"\n\t        oUrl.hash = parser.hash;     // => \"#hash\"\n\t        oUrl.host = parser.host;     // => \"example.com:3000\"\n\t        oUrl.queryString = queryString.parse(parser.search);\n\t\n\t        return oUrl;\n\t    }\n\t\n\t\n\t};\n\t\n\tmodule.exports = url;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tif (typeof Object.create === 'function') {\n\t    // implementation from standard node.js 'util' module\n\t    module.exports = function inherits(ctor, superCtor) {\n\t        ctor.super_ = superCtor;\n\t        ctor.prototype = Object.create(superCtor.prototype, {\n\t            constructor: {\n\t                value: ctor,\n\t                enumerable: false,\n\t                writable: true,\n\t                configurable: true\n\t            }\n\t        });\n\t    };\n\t} else {\n\t    // old school shim for old browsers\n\t    module.exports = function inherits(ctor, superCtor) {\n\t        ctor.super_ = superCtor;\n\t        var TempCtor = function () {};\n\t        TempCtor.prototype = superCtor.prototype;\n\t        ctor.prototype = new TempCtor();\n\t        ctor.prototype.constructor = ctor;\n\t    };\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tfunction createDescriptor(e,c,w,v){\n\t    return {\n\t        enumerable : e,\n\t        configurable : c,\n\t        writable : w,\n\t        value : v\n\t    };\n\t}\n\t\n\tmodule.exports = {\n\t\n\t    readOnly : function(obj, key){\n\t\n\t        if(Array.isArray(key)){\n\t            key.forEach(function(k){\n\t                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\n\t            });\n\t        }else{\n\t            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\n\t        }\n\t\n\t    },\n\t\n\t    private : function(obj, key){\n\t\n\t        if(Array.isArray(key)){\n\t            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\n\t        }else{\n\t            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\n\t        }\n\t    }\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {\n\t\n\t    isString : function(obj){\n\t        return typeof obj === 'string';\n\t    },\n\t\n\t    isNull : function(obj){\n\t        return obj === null;\n\t    },\n\t\n\t    isBoolean : function(obj){\n\t        return typeof obj === 'boolean';\n\t    },\n\t\n\t    isNumber : function(obj){\n\t        return typeof obj === 'number';\n\t    },\n\t\n\t    isObject : function(obj){\n\t        return obj === Object(obj);\n\t    },\n\t\n\t    isArray : function(obj){\n\t        return obj.constructor === Array;\n\t    },\n\t\n\t    isFunction : function(obj){\n\t        return typeof obj === 'function';\n\t    }\n\t\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\n\t */\n\t\n\t/*!\n\t query-string\n\t Parse and stringify URL query strings\n\t https://github.com/sindresorhus/query-string\n\t by Sindre Sorhus\n\t MIT License\n\t */\n\t\n\tvar queryString = {};\n\t\n\tqueryString.parse = function (str) {\n\t    if (typeof str !== 'string') {\n\t        return {};\n\t    }\n\t\n\t    str = str.trim().replace(/^(\\?|#)/, '');\n\t\n\t    if (!str) {\n\t        return {};\n\t    }\n\t\n\t    return str.trim().split('&').reduce(function (ret, param) {\n\t        var parts = param.replace(/\\+/g, ' ').split('=');\n\t        var key = parts[0];\n\t        var val = parts[1];\n\t\n\t        key = decodeURIComponent(key);\n\t        // missing `=` should be `null`:\n\t        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t        val = val === undefined ? null : decodeURIComponent(val);\n\t\n\t        if (!ret.hasOwnProperty(key)) {\n\t            ret[key] = val;\n\t        } else if (Array.isArray(ret[key])) {\n\t            ret[key].push(val);\n\t        } else {\n\t            ret[key] = [ret[key], val];\n\t        }\n\t\n\t        return ret;\n\t    }, {});\n\t};\n\t\n\tqueryString.stringify = function (obj) {\n\t    return obj ? Object.keys(obj).map(function (key) {\n\t        var val = obj[key];\n\t\n\t        if (Array.isArray(val)) {\n\t            return val.map(function (val2) {\n\t                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\n\t            }).join('&');\n\t        }\n\t\n\t        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\n\t    }).join('&') : '';\n\t};\n\t\n\tmodule.exports = queryString;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar types = util.types;\n\t\n\t\n\t/**\n\t * @namespace Client\n\t *\n\t */\n\tfunction ChannelClient(id, attributes, isHost, connectTime){\n\t\n\t    if(!types.isString(id)) throw new TypeError('id must be a valid string');\n\t    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\n\t\n\t    /**\n\t     * The id of the client\n\t     *\n\t     * @name id\n\t     * @memberOf Client.prototype\n\t     * @type {String}\n\t     * @readonly\n\t     *\n\t     */\n\t    this.id = id;\n\t\n\t    /**\n\t     * A map of attributes passed by the client when connecting\n\t     *\n\t     * @name attributes\n\t     * @memberOf Client.prototype\n\t     * @type {Object}\n\t     * @readonly\n\t     *\n\t     */\n\t    this.attributes = attributes || {};\n\t\n\t    /**\n\t     * Flag for determining if the client is the host\n\t     *\n\t     * @name isHost\n\t     * @memberOf Client.prototype\n\t     * @type {Boolean}\n\t     * @readonly\n\t     *\n\t     */\n\t    this.isHost = isHost;\n\t\n\t    /**\n\t     * The time which the client connected in epoch milliseconds\n\t     *\n\t     * @name connectTime\n\t     * @memberOf Client.prototype\n\t     * @type {Number}\n\t     * @readonly\n\t     *\n\t     */\n\t    this.connectTime = connectTime || Date.now();\n\t\n\t    Object.freeze(this.attributes);\n\t    Object.freeze(this);\n\t\n\t}\n\t\n\tmodule.exports = ChannelClient;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar util = __webpack_require__(5);\n\tvar types = util.types;\n\t\n\t/**\n\t * A list of clients\n\t * @namespace ClientList\n\t * @extends Array\n\t */\n\t\n\tfunction ClientList(channel){\n\t\n\t    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\n\t\n\t    this.channel = channel;\n\t\n\t    ClientList.super_.call(this);\n\t\n\t}\n\t\n\tutil.inherits(ClientList, Array);\n\t\n\t/***\n\t * Clears the list\n\t * @protected\n\t */\n\tClientList.prototype.clear = function(){\n\t    this.length = 0;\n\t};\n\t\n\t/***\n\t * Removes an client from the list\n\t * @protected\n\t */\n\tClientList.prototype.remove = function(item){\n\t    var i = this.indexOf(item);\n\t    if(i !== -1) {\n\t        this.splice(i, 1);\n\t        return item;\n\t    }\n\t    return null;\n\t};\n\t\n\t\n\t/**\n\t * Returns a client by id\n\t *\n\t * @param {String} id The client\n\t * @return {Client}\n\t *\n\t */\n\tClientList.prototype.getById = function(id){\n\t\n\t    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\n\t    for(var i=0; i<this.length; i++){\n\t        if(this[i].id === id) return this[i];\n\t    }\n\t    return null;\n\t};\n\t\n\t\n\t/**\n\t * A reference to your client\n\t *\n\t * @member {Client} ClientList#me\n\t * @readonly\n\t */\n\tObject.defineProperty(ClientList.prototype, 'me', {\n\t    get : function(){\n\t        return this.getById(this.channel.clientId);\n\t    }\n\t});\n\t\n\t\n\tmodule.exports = ClientList;\n\t\n\n\n/***/ }\n/******/ ])\n\n\n/** WEBPACK FOOTER **\n ** msf-2.0.13.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ed7d6cf98eadde729019\n **/","\"use strict\";\n\nvar msf = require('./lib/msf');\n\nif (typeof define === 'function' && define.amd) {\n    define(function() { return msf; });\n} else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = msf;\n} else {\n    window.msf = msf;\n}\n\nmodule.exports = msf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar EventEmitter = require('./EventEmitter');\nvar Service = require('./Service');\nvar Search = require('./Search');\n\n// We will use a singleton for search so that we don't create multiple frames in the page\nvar search = null;\n\n\n/**\n * The entry point for the API\n *\n * @namespace msf\n * @type {EventEmitter}\n *\n */\nvar msf = new EventEmitter();\n\n\n/**\n * Searches the local network for compatible multiscreen services\n *\n * @param {Function} [callback] If a callback is passed the search is immediately started.\n * @param {Error} callback.err The callback handler\n * @param {Array} callback.result An array of {@link Service} instances found on the network\n * @returns {Search} A search instance (a singleton is used to reduce page resources)\n *\n */\nmsf.search = function(callback){\n\n    // Create the single instance if we don't already have one\n    if(!search) search = new Search();\n\n    // If there is a callback defined, listen once for results and start the search\n    if(callback) {\n        search.once('found',function(services){\n            callback(null, services);\n        });\n\n        // start on next tick to support search callbacks and events\n        setTimeout(function(){ search.start(); },0);\n\n    }\n\n    return search;\n\n};\n\n\n/**\n * Retrieves a reference to the service running on the current device\n *\n * @param {Function} callback The callback handler\n * @param {Error} callback.error\n * @param {Service} callback.service The service instance\n *\n */\nmsf.local = function(callback){\n\n    Service.getLocal(callback);\n\n};\n\n/**\n * Retrieves a service instance by it's uri\n *\n * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\n * @param {Function} callback The callback handler\n * @param {Error} callback.error\n * @param {Service} callback.service The service instance\n *\n */\nmsf.remote = function(uri, callback){\n\n    Service.getByURI(uri, callback);\n\n};\n\n\n\nmodule.exports = msf;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/msf.js\n ** module id = 1\n ** module chunks = 0\n **/","/* jshint newcap: false, -W040: false, -W004: false, -W003 : false */\n\n\"use strict\";\n\n/**\n * Based on nodejs EventEmitter\n *\n * - addition of 'off' method as an alias to `removeListener`\n *\n * All objects which emit events are instances of EventEmitter.\n * For more information see http://nodejs.org/api/events.html\n *\n * @namespace EventEmitter\n *\n */\n\n\n/**\n * Adds a listener to the end of the listeners array for the specified event.\n * @method addListener\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to listen to\n * @param {Function} listener The function to invoke when the event occurs\n * @return EventEmitter\n *\n */\n\n/**\n * Alias for addListener method\n * @method on\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to listen to\n * @param {Function} listener The function to invoke when the event occurs\n * @return EventEmitter\n *\n */\n\n/**\n * Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed.\n * @method once\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to listen to\n * @param {Function} listener The function to invoke when the event occurs\n * return EventEmitter\n *\n */\n\n/**\n * Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener.\n * @method removeListener\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to stop listening to\n * @param {Function} listener The function that was originally add to handle the event\n * @return EventEmitter\n *\n */\n\n/**\n * Alias for removeListener\n * @method off\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to stop listening to\n * @param {Function} listener The function that was originally add to handle the event\n * @return EventEmitter\n *\n */\n\n/**\n * Removes all listeners, or those of the specified event.\n * @method removeAllListeners\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name to stop listening to\n * @return EventEmitter\n *\n */\n\n/**\n * By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.\n * @method setMaxListeners\n * @memberOf EventEmitter.prototype\n * @param {Number} n The maximum number of listeners\n *\n */\n\n/**\n * Returns an array of listeners for the specified event.\n * @method listeners\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name the listeners are currently bound to\n * @return Array\n *\n */\n\n/**\n * Returns true if event had listeners, false otherwise.\n * @method emit\n * @memberOf EventEmitter.prototype\n * @param {String} event The event name the listeners are currently bound to\n * @param {any}[args]*\n * @return Boolean\n *\n */\n\n/**\n * Returns true if event had listeners, false otherwise.\n * @method listenerCount\n * @static\n * @memberOf EventEmitter\n * @param {EventEmitter} emitter\n * @param {String} event The event name the listeners are currently bound to\n * @return Number\n *\n */\n\n\n/**\n This event is emitted any time someone adds a new listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\n @event EventEmitter#newListener\n @property {String} event The event name\n @property {Function} listener The event handler function\n **/\n\n/**\n This event is emitted any time someone removes a listener. It is unspecified if listener is in the list returned by emitter.listeners(event).\n @event EventEmitter#removeListener\n @property {String} event The event name\n @property {Function} listener The event handler function\n **/\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n this._events = this._events || {};\n this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n if (!isNumber(n) || n < 0 || isNaN(n))\n  throw TypeError('n must be a positive number');\n this._maxListeners = n;\n return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n var er, handler, len, args, i, listeners;\n\n if (!this._events)\n  this._events = {};\n\n // If there is no 'error' event listener then throw.\n if (type === 'error') {\n  if (!this._events.error ||\n      (isObject(this._events.error) && !this._events.error.length)) {\n   er = arguments[1];\n   if (er instanceof Error) {\n    throw er; // Unhandled 'error' event\n   }\n   throw TypeError('Uncaught, unspecified \"error\" event.');\n  }\n }\n\n handler = this._events[type];\n\n if (isUndefined(handler))\n  return false;\n\n if (isFunction(handler)) {\n  switch (arguments.length) {\n   // fast cases\n   case 1:\n    handler.call(this);\n    break;\n   case 2:\n    handler.call(this, arguments[1]);\n    break;\n   case 3:\n    handler.call(this, arguments[1], arguments[2]);\n    break;\n   // slower\n   default:\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n     args[i - 1] = arguments[i];\n    handler.apply(this, args);\n  }\n } else if (isObject(handler)) {\n  len = arguments.length;\n  args = new Array(len - 1);\n  for (i = 1; i < len; i++)\n   args[i - 1] = arguments[i];\n\n  listeners = handler.slice();\n  len = listeners.length;\n  for (i = 0; i < len; i++)\n   listeners[i].apply(this, args);\n }\n\n return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n var m;\n\n if (!isFunction(listener))\n  throw TypeError('listener must be a function');\n\n if (!this._events)\n  this._events = {};\n\n // To avoid recursion in the case that type === \"newListener\"! Before\n // adding it to the listeners, first emit \"newListener\".\n if (this._events.newListener)\n  this.emit('newListener', type,\n      isFunction(listener.listener) ?\n          listener.listener : listener);\n\n if (!this._events[type])\n // Optimize the case of one listener. Don't need the extra array object.\n  this._events[type] = listener;\n else if (isObject(this._events[type]))\n // If we've already got an array, just append.\n  this._events[type].push(listener);\n else\n // Adding the second element, need to change to array.\n  this._events[type] = [this._events[type], listener];\n\n // Check for listener leak\n if (isObject(this._events[type]) && !this._events[type].warned) {\n  var m;\n  if (!isUndefined(this._maxListeners)) {\n   m = this._maxListeners;\n  } else {\n   m = EventEmitter.defaultMaxListeners;\n  }\n\n  if (m && m > 0 && this._events[type].length > m) {\n   this._events[type].warned = true;\n   console.error('(node) warning: possible EventEmitter memory ' +\n       'leak detected. %d listeners added. ' +\n       'Use emitter.setMaxListeners() to increase limit.',\n       this._events[type].length);\n   if (typeof console.trace === 'function') {\n    // not supported in IE 10\n    console.trace();\n   }\n  }\n }\n\n return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n if (!isFunction(listener))\n  throw TypeError('listener must be a function');\n\n var fired = false;\n\n function g() {\n  this.removeListener(type, g);\n\n  if (!fired) {\n   fired = true;\n   listener.apply(this, arguments);\n  }\n }\n\n g.listener = listener;\n this.on(type, g);\n\n return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n var list, position, length, i;\n\n if (!isFunction(listener))\n  throw TypeError('listener must be a function');\n\n if (!this._events || !this._events[type])\n  return this;\n\n list = this._events[type];\n length = list.length;\n position = -1;\n\n if (list === listener ||\n     (isFunction(list.listener) && list.listener === listener)) {\n  delete this._events[type];\n  if (this._events.removeListener)\n   this.emit('removeListener', type, listener);\n\n } else if (isObject(list)) {\n  for (i = length; i-- > 0;) {\n   if (list[i] === listener ||\n       (list[i].listener && list[i].listener === listener)) {\n    position = i;\n    break;\n   }\n  }\n\n  if (position < 0)\n   return this;\n\n  if (list.length === 1) {\n   list.length = 0;\n   delete this._events[type];\n  } else {\n   list.splice(position, 1);\n  }\n\n  if (this._events.removeListener)\n   this.emit('removeListener', type, listener);\n }\n\n return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n var key, listeners;\n\n if (!this._events)\n  return this;\n\n // not listening for removeListener, no need to emit\n if (!this._events.removeListener) {\n  if (arguments.length === 0)\n   this._events = {};\n  else if (this._events[type])\n   delete this._events[type];\n  return this;\n }\n\n // emit removeListener for all listeners on all events\n if (arguments.length === 0) {\n  for (key in this._events) {\n   if (key === 'removeListener') continue;\n   this.removeAllListeners(key);\n  }\n  this.removeAllListeners('removeListener');\n  this._events = {};\n  return this;\n }\n\n listeners = this._events[type];\n\n if (isFunction(listeners)) {\n  this.removeListener(type, listeners);\n } else {\n  // LIFO order\n  while (listeners.length)\n   this.removeListener(type, listeners[listeners.length - 1]);\n }\n delete this._events[type];\n\n return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n var ret;\n if (!this._events || !this._events[type])\n  ret = [];\n else if (isFunction(this._events[type]))\n  ret = [this._events[type]];\n else\n  ret = this._events[type].slice();\n return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n var ret;\n if (!emitter._events || !emitter._events[type])\n  ret = 0;\n else if (isFunction(emitter._events[type]))\n  ret = 1;\n else\n  ret = emitter._events[type].length;\n return ret;\n};\n\nfunction isFunction(arg) {\n return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/EventEmitter.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar props = util.props;\nvar Application = require('./Application');\nvar Channel = require('./Channel');\n\n\n/**\n * A Service instance represents the multiscreen service root on the remote device\n * Use the class to control top level services of the device\n *\n * @namespace Service\n *\n */\n\nfunction Service(description){\n\n    /**\n     * The id of the service\n     *\n     * @member {String} Service#id\n     * @readonly\n     */\n    this.id = description.id;\n\n    /**\n     * The name of the service (Living Room TV)\n     *\n     * @member {String} Service#name\n     * @readonly\n     */\n    this.name = description.name;\n\n    /**\n     * The version of the service (x.x.x)\n     *\n     * @member {String} Service#version\n     * @readonly\n     */\n    this.version = description.version;\n\n    /**\n     * The type of the service (Samsung SmartTV)\n     *\n     * @member {String} Service#type\n     * @readonly\n     */\n    this.type = description.type;\n\n    /**\n     * The uri of the service (http://<ip>:<port>/api/v2/)\n     *\n     * @member {String} Service#uri\n     * @readonly\n     */\n    this.uri = description.uri;\n\n    /**\n     * A hash of additional information about the device the service is running on\n     *\n     * @member {String} Service#device\n     * @readonly\n     */\n    this.device = description.device;\n\n    props.readOnly(this,['id','name','version','type','uri','device']);\n\n}\n\n/**\n * Factory method for creating application instances belonging to that service\n *\n * @param {String} id An installed application id or url of the web application\n * @param {String} channelURI The uri the underlying channel will connect to.\n * @returns {Application}\n *\n */\nService.prototype.application = function(id, channelURI){\n\n    return new Application(this, id, channelURI);\n\n};\n\n/**\n * creates a channel of the service ('mychannel')\n *\n * @param {String} uri The uri of the Channel\n * @returns {Channel}\n */\nService.prototype.channel = function(uri){\n\n    return new Channel(this, uri);\n\n};\n\n\n/***\n * Retrieves a reference to the service running on the current device\n *\n * @protected\n *\n * @param {Function} callback The callback handler\n * @param {Error} callback.err The callback handler\n * @param {Service} callback.service The service instance\n *\n */\nService.getLocal = function(callback){\n\n    Service.getByURI('http://127.0.0.1:8001/api/v2/', callback);\n\n};\n\n/***\n * Retrieves a service instance by it's uri\n *\n * @protected\n *\n * @param {String} uri The uri of the service (http://<ip>:<port>/api/v2/)\n * @param {Function} callback The callback handler\n * @param {Error} callback.err The callback handler\n * @param {Service} callback.service The service instance\n *\n */\nService.getByURI = function(uri, callback){\n\n    var oReq = new XMLHttpRequest();\n    oReq.timeout = 5000;\n    oReq.ontimeout = function(){callback();};\n    oReq.onload = function() {\n\n        if(this.status === 200){\n            try{\n                var result = JSON.parse(this.responseText);\n                callback(null, new Service(result));\n            }catch(e){  callback(e); }\n        }else{\n            callback();\n        }\n    };\n    oReq.open(\"get\", uri, true);\n    oReq.send();\n\n};\n\n\nmodule.exports = Service;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Service.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar props = util.props;\nvar EventEmitter = require('./EventEmitter');\n\n\n/**\n * Provides facilities to stop and start multiscreen service searches.\n *\n * @namespace Search\n * @extends EventEmitter\n *\n */\n\nfunction Search(){\n\n\n    Search.super_.call(this);\n\n    this.discoveryFrame = null;\n    this.status = Search.STATUS_STOPPED;\n\n    var self = this;\n\n    /* Create the discovery iframe and load the search page */\n\n    var frame = document.createElement('iframe');\n    frame.setAttribute('width', '1');\n    frame.setAttribute('height', '1');\n    frame.style.display = \"none\";\n    frame.src = 'http://multiscreen.samsung.com/discoveryservice/v2/discover';\n    document.body.appendChild(frame);\n\n    /* Add a 'message' listener to the window that checks incoming messages */\n\n    this.windowMessageListener = function(event){\n\n        if(event.source === frame.contentWindow){\n\n            // ready message\n            if(event.data && event.data.event === 'discovery.ready'){\n                self.discoveryFrame = event.source;\n                self.onSearchReady();\n            }\n\n            // result message\n            else if(event.data && event.data.event === 'discovery.result'){\n                var results = [];\n                var Service = require('./Service');\n                for(var i=0; i<event.data.result.length; i++){\n                    results.push(new Service(event.data.result[i]));\n                }\n                self.onSearchResult(results);\n            }\n\n            // error message\n            else if(event.data && event.data.event === 'discovery.error'){\n                self.onSearchError(event.data.error);\n                this.status = Search.STATUS_STOPPED;\n            }\n        }\n    };\n    window.addEventListener('message', this.windowMessageListener);\n\n    props.private(this,['discoveryFrame','windowMessageListener']);\n\n}\n\nutil.inherits(Search, EventEmitter);\n\n\n/***\n * @constant {string}\n * @private\n */\nSearch.STATUS_STOPPED = 'stopped';\n\n/***\n * @constant {string}\n * @private\n */\nSearch.STATUS_STARTED = 'started';\n\n/***\n * @private\n */\nSearch.prototype.onSearchReady = function(){\n    this.emit('ready');\n};\n\n\n\n/**\n * Fired when a search has discovered compatible services\n *\n * @event Search#found\n * @type {Array}\n */\n\n/***\n * @private\n */\nSearch.prototype.onSearchResult = function(results){\n    if(this.status !== Search.STATUS_STOPPED){\n        this.emit('found',results);\n    }\n    this.status = Search.STATUS_STOPPED;\n};\n\n\n/**\n * Fired when a search error has occurred\n *\n * @event Search#error\n * @type {Error}\n */\n\n/***\n * @private\n */\nSearch.prototype.onSearchError = function(error){\n    this.emit('error',error);\n    this.status = Search.STATUS_STOPPED;\n};\n\n\n/**\n * Starts the search, looking for devices it can reach on the local network\n * If a search is already in progress it will NOT begin a new search\n */\nSearch.prototype.start = function(){\n    if(this.status === Search.STATUS_STOPPED){\n        if(this.discoveryFrame){\n            this.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\n        }else{\n            var self = this;\n            this.once('ready',function(){\n                self.discoveryFrame.postMessage({method:'discovery.search'}, \"*\");\n            });\n        }\n\n        this.status = Search.STATUS_STARTED;\n        /**\n         * Fired when a search has been started\n         *\n         * @event Search#start\n         * @type {Search}\n         */\n        this.emit('start', this);\n    }else{\n        console.warn('a previous search is already in progress');\n    }\n};\n\n/**\n * Stops the current search in progress (no 'found' events or search callbacks will fire)\n */\nSearch.prototype.stop = function(){\n    this.status = Search.STATUS_STOPPED;\n    /**\n     * Fired when a search has been stopped\n     *\n     * @event Search#stop\n     * @type {Search}\n     */\n    this.emit('stop', this);\n};\n\n\nmodule.exports = Search;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Search.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = {\n\n    url         : require('./url'),\n    inherits    : require('./inherits'),\n    props       : require('./props'),\n    types       : require('./types'),\n    queryString : require('./querystring')\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/index.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar types = util.types;\nvar props = util.props;\nvar Channel = require('./Channel');\n\n\n/**\n * An Application represents an application on the local or remote device.\n * Use the class to control various aspects of the application such launching the app or getting information\n *\n * @namespace Application\n * @extends Channel\n *\n */\n\nfunction Application(service, id, channelURI){\n\n    /* Type checking */\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\n    if(!types.isString(channelURI)) throw new TypeError('channelId must be a valid string');\n\n    /***\n     * The type of application (web application or installable app)\n     * @member {String} Application#type\n     * @private\n     */\n    this.type = id.match(/(file:\\/\\/|http(s)?:\\/\\/)/gmi) ? 'webapplication' : 'application';\n\n    /* Super Constructor */\n    Application.super_.call(this, service, channelURI);\n\n\n    /**\n     * The id of the application (this can be a url or installed application id)\n     * @member {String} Application#id\n     * @readonly\n     */\n    this.id = id;\n\n    /**\n     * Auto starts the application when connect is called\n     * This configuration property has no effect when used in a SmartTV application\n     *\n     * @member {Boolean} Application#startOnConnect\n     * @default [true]\n     * @example\n     * ```\n     * var app = service.application('myid');\n     * app.startOnConnect = false;\n     * app.connect(); // The application will not start on the TV\n     * ```\n     */\n    this.startOnConnect      = true;\n\n    /**\n     * Stops the application when disconnect is called and your client is the last client connected\n     * This configuration property has no effect when used in a SmartTV application\n     *\n     * @member {Boolean} Application#stopOnDisconnect\n     * @default [true]\n     * @example\n     * ```\n     * var app = service.application('myid');\n     * app.stopOnDisconnect = false;\n     * app.disconnect(); // The application will not close on the TV\n     * ```\n     */\n    this.stopOnDisconnect    = true;\n\n    /**\n     * Disconnects your client when the host connection ends (when the host application is exited)\n     * This configuration property has no effect when used in a SmartTV application\n     *\n     * @member {Boolean} Application#disconnectWithHost\n     * @default [true]\n     * @example\n     * ```\n     * app.on('clientDisconnect', function(client){\n     *    // client.isHost == true; but you will not be disconnected.\n     * });\n     * ```\n     */\n    this.disconnectWithHost  = true;\n\n\n    var self = this;\n\n    /* Listen for connect events and call start if startOnConnect */\n    this.on('connect', function(client){\n        if(self.startOnConnect && !self.clients.me.isHost) this.start();\n    });\n\n    /* Listen for clientDisconnect events and disconnect if host disconnects  */\n    this.on('clientDisconnect', function(client){\n        if(self.disconnectWithHost && client.isHost) this.disconnect();\n    });\n\n    /* Overwrite super disconnect and stop the app if stopOnDisconnect */\n    this.disconnect = function(callback){\n        if(self.stopOnDisconnect && self.clients.length < 3) {\n            self.stop(function(){\n                Channel.prototype.disconnect.call(self, callback);\n            });\n        }else{\n            Channel.prototype.disconnect.call(self, callback);\n        }\n    };\n\n    props.readOnly(this,'id');\n    props.private(this,'type');\n\n}\n\nutil.inherits(Application, Channel);\n\n\n/**\n * Retrieves information about the Application on the remote device\n *\n * @param {Function} callback The callback handler\n * @param {Function} callback.err The callback handler\n * @param {Object} callback.result The callback handler\n *\n */\nApplication.prototype.getInfo = function(callback){\n\n    if(this.type === 'webapplication'){\n        this.invoke('ms.webapplication.get', { url: this.id }, callback);\n    }else{\n        this.invoke('ms.application.get', { id : this.id }, callback);\n    }\n\n};\n\n\n/**\n * Launches the application on the remote device\n *\n * @param {Function} callback The callback handler\n * @param {Function} callback.err The callback handler\n *\n */\nApplication.prototype.start = function(callback){\n\n    if(this.type === 'webapplication'){\n        this.invoke('ms.webapplication.start', { url : this.id }, callback);\n    }else{\n        this.invoke('ms.application.start', { id : this.id }, callback);\n    }\n\n};\n\n\n/**\n * Stop the application on the remote device\n *\n * @param {Function} callback The callback handler\n * @param {Function} callback.err The callback handler\n *\n */\nApplication.prototype.stop = function(callback){\n\n    if(this.type === 'webapplication'){\n        this.invoke('ms.webapplication.stop', { url : this.id }, callback);\n    }else{\n        this.invoke('ms.application.stop', { id : this.id }, callback);\n    }\n\n};\n\n\n/**\n * Installs the application on the remote device\n *\n * @param {Function} callback The callback handler\n * @param {Function} callback.err The callback handler\n *\n */\nApplication.prototype.install = function(callback){\n\n    if(this.type === 'webapplication') throw new Error('install cannot be called on web applications');\n    this.invoke('ms.application.install', { id : this.id }, callback);\n\n};\n\n\n\n\nmodule.exports = Application;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Application.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar types = util.types;\nvar props = util.props;\nvar EventEmitter = require('./EventEmitter');\nvar Client = require('./Client');\nvar ClientList = require('./ClientList');\n\n\n/**\n * A Channel is a discreet connection where multiple clients can communicate\n * @namespace Channel\n * @extends EventEmitter\n\n */\nfunction Channel(service, uri){\n\n    /* Type checking */\n    if(!types.isObject(service)) throw new TypeError('service must be of type Service');\n    if(!types.isString(uri)) throw new TypeError('uri must be a valid string');\n\n    /* Super Construction */\n    Channel.super_.call(this);\n\n    var self = this;\n    var oServiceUrl = util.url.parse(service.uri);\n\n    /**\n     * The uri of the channel ('chat')\n     *\n     * @member {String} Channel#uri\n     * @readonly\n     *\n     */\n    this.uri = uri;\n\n    /**\n     * The collection of clients currently connected to the channel\n     *\n     * @member {ClientList} Channel#clients\n     * @readonly\n     *\n     */\n    this.clients = new ClientList(this);\n\n    /**\n     * The connection status of the channel\n     *\n     * @member {Boolean} Channel#isConnected\n     * @readonly\n     *\n     */\n    Object.defineProperty(this, 'isConnected', {\n        get : function(){\n            return self.connection && self.connection.readyState === 1;\n        }\n    });\n\n    /***\n     * The id assigned to your client upon connection\n     *\n     * @member {String} Channel#clientId\n     * @private\n     *\n     */\n    this.clientId = null;\n\n    /***\n     * The underlying web socket connection\n     *\n     * @member {WebSocket} Channel#connection\n     * @private\n     *\n     */\n    this.connection = null;\n\n    /***\n     * A map of message handler still waiting for responses\n     *\n     * @member {Object} Channel#resultHandlers\n     * @private\n     *\n     */\n    this.resultHandlers = {};\n\n    /***\n     * The url for the websocket to connect to\n     *\n     * @member {Object} Channel#connectionUrl\n     * @private\n     *\n     */\n    this.connectionUrl = 'ws://' + oServiceUrl.host + oServiceUrl.pathname + 'channels/' + uri;\n\n\n    props.private(this, ['clientId','connection','resultHandlers','connectionUrl']);\n    props.readOnly(this, ['uri','clients']);\n}\n\n\nutil.inherits(Channel, EventEmitter);\n\n\n/*\n Packs messages with payloads into binary message\n */\nChannel.packMessage = function(oMsg, payload){\n\n    // convert js object to string\n    var msg = JSON.stringify(oMsg);\n\n    // get byte length of the string\n    var msgByteLength = new Blob([msg]).size;\n\n    // create 2 byte header which contains the length of the string (json) message\n    var hBuff = new ArrayBuffer(2);\n    var hView = new DataView(hBuff);\n    hView.setUint16(0,msgByteLength);\n\n    // binary packed message and payload\n    return new Blob([hBuff, msg, payload]);\n\n};\n\n/*\n Unpacks binary messages\n */\nChannel.unpackMessage = function(buffer){\n\n    var json = '';\n    var view = new DataView(buffer);\n    var msgByteLen = view.getUint16(0);\n\n    for (var i = 0; i < msgByteLen; i++) {\n        json += String.fromCharCode(view.getUint8(i+2));\n    }\n\n    var payload = buffer.slice(2+msgByteLen);\n    var message = JSON.parse(json);\n\n    return {payload : payload, message : message};\n\n};\n\n\n/***\n * Invokes and RPC method on the server\n *\n * @protected\n *\n * @param {String} method The name of the method to invoke\n * @param {Object} params Named params to pass to the method\n * @param {Function} [callback] The success callback handler\n * @param {Error} callback.error Any error that may have occurred\n * @param {Boolean} callback.success\n * @param {Boolean} [isNotification=false] If true the message will have no id and no response handler will be stored\n * @param {ArrayBuffer|Blob} [payload] Any binary data to send along with the message\n *\n */\nChannel.prototype.invoke = function(method, params, callback, isNotification, payload){\n\n    if(!this.isConnected) throw new Error(\"the channel is disconnected\");\n    if(!types.isString(method))throw new TypeError('method must be a valid string');\n\n    params = params || {};\n\n    var msg = {\n        method  : method,\n        params  : params\n    };\n\n    if(callback && !isNotification){\n        msg.id = Date.now();\n        this.resultHandlers[msg.id] = callback;\n    }\n\n    if(payload){\n        msg = Channel.packMessage(msg,payload);\n    }else{\n        msg = JSON.stringify(msg);\n    }\n\n    this.connection.send(msg);\n};\n\n/**\n * Connects to the channel\n *\n * @param {Object} attributes Any attributes you want to associate with the client (ie. {name:\"FooBar\"}\n * @param {Function} callback The success callback handler\n * @param {Error} callback.error Any error that may have occurred\n * @param {Channel} callback.channel The channel instance that connected\n *\n */\nChannel.prototype.connect = function(attributes, callback){\n\n    if(types.isFunction(attributes) && !callback){\n        callback = attributes;\n        attributes = {};\n    }else{\n        attributes = attributes || {};\n    }\n\n    // Validate arguments and connection state\n    if(!types.isObject(attributes))throw new TypeError('attributes must be a valid object');\n    if(callback && !types.isFunction(callback))throw new TypeError('callback must be a valid function');\n    if(this.isConnected) return console.warn('Channel is already connected.');\n\n    // TODO : Need to merge query string just in case the connection url already has a query (although it shouldn't)\n    var u = this.connectionUrl + '?' + util.queryString.stringify(attributes);\n\n    // Connect the websocket and add our listeners\n    if(!this.connection){\n        this.connection = new WebSocket(u);\n        this.connection.binaryType = \"arraybuffer\";\n        this.connection.onopen = this._onSocketOpen.bind(this);\n        this.connection.onerror = this._onSocketError.bind(this);\n        this.connection.onclose = this._onSocketClose.bind(this);\n        this.connection.onmessage = this._onSocketMessage.bind(this);\n    }\n\n    // Listen once for connect if there was a callback\n    var self = this;\n    if(callback){\n        this.once('connect', function(client){\n            callback(null, self);\n        });\n    }\n\n\n};\n\n\n/**\n * Disconnects from the channel\n *\n * @param {Function} callback The success callback handler\n * @param {Error} callback.error Any error that may have occurred\n * @param {Channel} callback.channel The channel instance\n *\n */\nChannel.prototype.disconnect = function(callback){\n\n    if(!this.isConnected) throw new Error(\"the channel is already disconnected\");\n    this.connection.close();\n    var self = this;\n    setTimeout(function(){\n        if(callback) callback(null, self);\n    },0);\n\n};\n\n\n/**\n * Publish an event message to the specified target or targets.\n * Targets can be in the for of a clients id, an array of client ids or one of the special message target strings (ie. \"all\" or \"host\"}\n *\n * @param {String} event The name of the event to emit\n * @param {any} [message] Any data associated with the event\n * @param {String|Array} [target='broadcast'] The target recipient(s) of the message\n * @param {Blob|ArrayBuffer} [payload] Any binary data to send with the message\n *\n */\nChannel.prototype.publish = function(event, message, target, payload){\n\n    target = target || 'broadcast';\n    message = message || null;\n\n    if(!this.isConnected) throw new Error(\" the channel is not connected\");\n    if(!types.isString(event))throw new TypeError('event must be a valid string');\n\n    if(!(types.isString(target) || types.isArray(target))) throw new TypeError('targets must be a valid string or array');\n\n    this.invoke('ms.channel.emit',{\n        event   : event,\n        data    : message,\n        to      : target\n    }, null, true, payload);\n\n};\n\n\n\n\n\n// TODO : Make these non enumerable\n\n\nChannel.prototype._onSocketOpen = function() {\n    // nothing to do here for now\n};\n\nChannel.prototype._onSocketClose = function() {\n    /**\n     * Fired when a channel disconnects\n     *\n     * @event Channel#disconnect\n     * @type {Client}\n     */\n    var client = this.clients.me;\n    this.clients.clear();\n    this.emit('disconnect',client);\n};\n\nChannel.prototype._onSocketError = function() {\n    this.emit('error', new Error(\"WebSocket error\"));\n};\n\n\nChannel.prototype._onSocketMessage = function(msg){\n\n    var client;\n    var payload;\n\n    try{\n        if(typeof msg.data === \"string\"){\n            msg = JSON.parse(msg.data);\n        }else{\n            var unpacked = Channel.unpackMessage(msg.data);\n            msg = unpacked.message;\n            payload = unpacked.payload;\n        }\n    } catch (e) {\n        console.warn('unable to parse message', msg);\n        return;\n    }\n\n    if(msg.id && (msg.result || msg.error)){\n\n        if(!this.resultHandlers[msg.id]){\n            console.warn('unable to find result handler for result message ', msg);\n            return;\n        }\n\n        this.resultHandlers[msg.id](msg.error,msg.result);\n\n    }else if (msg.event){\n\n        switch(msg.event){\n\n            case 'ms.channel.connect' :\n\n                // Store my id\n                this.clientId = msg.data.id;\n\n                // Store the current connected client\n                msg.data.clients.forEach(function(clientInfo){\n\n                    // Create a client and add to our list\n                    client = new Client(clientInfo.id, clientInfo.attributes, clientInfo.isHost);\n                    this.clients.push(client);\n\n                },this);\n\n                /**\n                 * Fired when a channel makes a connection\n                 *\n                 * @event Channel#connect\n                 * @type {Client}\n                 */\n                this.emit('connect',this.clients.me);\n\n                break;\n\n            case 'ms.channel.clientConnect' :\n\n                client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\n                this.clients.push(client);\n\n                /**\n                 * Fired when a peer client channel makes a connection\n                 *\n                 * @event Channel#clientConnect\n                 * @type {Client}\n                 */\n\n                this.emit('clientConnect',client);\n                break;\n\n            case 'ms.channel.clientDisconnect' :\n\n                client = this.clients.getById(msg.data.id);\n                if(client) this.clients.remove(client);\n                else {\n                    console.warn('client '+msg.data.id+' could not be found, so it was not removed from the client list');\n                    client = new Client(msg.data.id, msg.data.attributes, msg.data.isHost);\n                }\n\n                /**\n                 * Fired when a peer client disconnects\n                 *\n                 * @event Channel#clientDisconnect\n                 * @type {Client}\n                 */\n                this.emit('clientDisconnect',client);\n                break;\n\n            case 'ms.channel.ready' :\n\n\n                /**\n                 * Convenience event indicating the host has connected and is ready to accept messages\n                 *\n                 * @event Channel#ready\n                 */\n                this.emit('ready');\n                break;\n\n\n            default :\n\n                client = this.clients.getById(msg.from);\n                var event = msg.event;\n                var data  = msg.data;\n\n                this.emit(event, data, client, payload);\n                break;\n\n        }\n\n    }else{\n        console.warn('unrecognized message type', msg);\n    }\n\n};\n\nmodule.exports = Channel;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Channel.js\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\nvar queryString = require('./querystring');\n\nvar url = {\n\n    isValid : function(u){\n\n        var pattern = /^(?:([A-Za-z]+):)?(\\/{0,3})([0-9.\\-A-Za-z]+)(?::(\\d+))?(?:\\/([^?#]*))?(?:\\?([^#]*))?(?:#(.*))?$/;\n        return u.match(pattern) ? true : false;\n    },\n\n    parse : function(u){\n\n        var oUrl = {};\n        var parser = document.createElement('a');\n        parser.href = u; // \"http://example.com:3000/pathname/?search=test#hash\";\n\n        oUrl.href = parser.href; // => \"http://ip:port/path/page?query=string#hash\"\n        oUrl.protocol = parser.protocol; // => \"http:\"\n        oUrl.hostname = parser.hostname; // => \"example.com\"\n        oUrl.port = parser.port;     // => \"3000\"\n        oUrl.pathname = parser.pathname; // => \"/pathname/\"\n        oUrl.search = parser.search;   // => \"?search=test\"\n        oUrl.hash = parser.hash;     // => \"#hash\"\n        oUrl.host = parser.host;     // => \"example.com:3000\"\n        oUrl.queryString = queryString.parse(parser.search);\n\n        return oUrl;\n    }\n\n\n};\n\nmodule.exports = url;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/url.js\n ** module id = 8\n ** module chunks = 0\n **/","\"use strict\";\n\nif (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n    };\n} else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function () {};\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n    };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/inherits.js\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\n\nfunction createDescriptor(e,c,w,v){\n    return {\n        enumerable : e,\n        configurable : c,\n        writable : w,\n        value : v\n    };\n}\n\nmodule.exports = {\n\n    readOnly : function(obj, key){\n\n        if(Array.isArray(key)){\n            key.forEach(function(k){\n                Object.defineProperty(obj, k, createDescriptor(true,true,false,obj[k]));\n            });\n        }else{\n            Object.defineProperty(obj, key, createDescriptor(true,true,false,obj[key]));\n        }\n\n    },\n\n    private : function(obj, key){\n\n        if(Array.isArray(key)){\n            key.forEach(function(k){ Object.defineProperty(obj, k, createDescriptor(false,true,true,obj[k])); });\n        }else{\n            Object.defineProperty(obj, key, createDescriptor(false,true,true,obj[key]));\n        }\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/props.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\n\nmodule.exports = {\n\n    isString : function(obj){\n        return typeof obj === 'string';\n    },\n\n    isNull : function(obj){\n        return obj === null;\n    },\n\n    isBoolean : function(obj){\n        return typeof obj === 'boolean';\n    },\n\n    isNumber : function(obj){\n        return typeof obj === 'number';\n    },\n\n    isObject : function(obj){\n        return obj === Object(obj);\n    },\n\n    isArray : function(obj){\n        return obj.constructor === Array;\n    },\n\n    isFunction : function(obj){\n        return typeof obj === 'function';\n    }\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/types.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\n/*\n    Derived work from Sidre Sorhus (https://github.com/sindresorhus/query-string)\n */\n\n/*!\n query-string\n Parse and stringify URL query strings\n https://github.com/sindresorhus/query-string\n by Sindre Sorhus\n MIT License\n */\n\nvar queryString = {};\n\nqueryString.parse = function (str) {\n    if (typeof str !== 'string') {\n        return {};\n    }\n\n    str = str.trim().replace(/^(\\?|#)/, '');\n\n    if (!str) {\n        return {};\n    }\n\n    return str.trim().split('&').reduce(function (ret, param) {\n        var parts = param.replace(/\\+/g, ' ').split('=');\n        var key = parts[0];\n        var val = parts[1];\n\n        key = decodeURIComponent(key);\n        // missing `=` should be `null`:\n        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n        val = val === undefined ? null : decodeURIComponent(val);\n\n        if (!ret.hasOwnProperty(key)) {\n            ret[key] = val;\n        } else if (Array.isArray(ret[key])) {\n            ret[key].push(val);\n        } else {\n            ret[key] = [ret[key], val];\n        }\n\n        return ret;\n    }, {});\n};\n\nqueryString.stringify = function (obj) {\n    return obj ? Object.keys(obj).map(function (key) {\n        var val = obj[key];\n\n        if (Array.isArray(val)) {\n            return val.map(function (val2) {\n                return encodeURIComponent(key) + '=' + encodeURIComponent(val2);\n            }).join('&');\n        }\n\n        return encodeURIComponent(key) + '=' + encodeURIComponent(val);\n    }).join('&') : '';\n};\n\nmodule.exports = queryString;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/util/querystring.js\n ** module id = 12\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar types = util.types;\n\n\n/**\n * @namespace Client\n *\n */\nfunction ChannelClient(id, attributes, isHost, connectTime){\n\n    if(!types.isString(id)) throw new TypeError('id must be a valid string');\n    if(attributes && !types.isObject(attributes)) throw new TypeError('attributes must be a valid object');\n\n    /**\n     * The id of the client\n     *\n     * @name id\n     * @memberOf Client.prototype\n     * @type {String}\n     * @readonly\n     *\n     */\n    this.id = id;\n\n    /**\n     * A map of attributes passed by the client when connecting\n     *\n     * @name attributes\n     * @memberOf Client.prototype\n     * @type {Object}\n     * @readonly\n     *\n     */\n    this.attributes = attributes || {};\n\n    /**\n     * Flag for determining if the client is the host\n     *\n     * @name isHost\n     * @memberOf Client.prototype\n     * @type {Boolean}\n     * @readonly\n     *\n     */\n    this.isHost = isHost;\n\n    /**\n     * The time which the client connected in epoch milliseconds\n     *\n     * @name connectTime\n     * @memberOf Client.prototype\n     * @type {Number}\n     * @readonly\n     *\n     */\n    this.connectTime = connectTime || Date.now();\n\n    Object.freeze(this.attributes);\n    Object.freeze(this);\n\n}\n\nmodule.exports = ChannelClient;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/Client.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\n\nvar util = require(\"./util\");\nvar types = util.types;\n\n/**\n * A list of clients\n * @namespace ClientList\n * @extends Array\n */\n\nfunction ClientList(channel){\n\n    if(!types.isObject(channel))throw new TypeError('channel must be of type Channel');\n\n    this.channel = channel;\n\n    ClientList.super_.call(this);\n\n}\n\nutil.inherits(ClientList, Array);\n\n/***\n * Clears the list\n * @protected\n */\nClientList.prototype.clear = function(){\n    this.length = 0;\n};\n\n/***\n * Removes an client from the list\n * @protected\n */\nClientList.prototype.remove = function(item){\n    var i = this.indexOf(item);\n    if(i !== -1) {\n        this.splice(i, 1);\n        return item;\n    }\n    return null;\n};\n\n\n/**\n * Returns a client by id\n *\n * @param {String} id The client\n * @return {Client}\n *\n */\nClientList.prototype.getById = function(id){\n\n    if(!types.isString(id) && !types.isNumber(id)) throw new TypeError('id must be a valid string or number');\n    for(var i=0; i<this.length; i++){\n        if(this[i].id === id) return this[i];\n    }\n    return null;\n};\n\n\n/**\n * A reference to your client\n *\n * @member {Client} ClientList#me\n * @readonly\n */\nObject.defineProperty(ClientList.prototype, 'me', {\n    get : function(){\n        return this.getById(this.channel.clientId);\n    }\n});\n\n\nmodule.exports = ClientList;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ClientList.js\n ** module id = 14\n ** module chunks = 0\n **/"],"sourceRoot":""}